# ArgoCD Helm values for resource-constrained cluster
# Conservative resource limits to leave headroom for application workloads

global:
  # Use ClusterIP for services (no LoadBalancer costs)
  # Access via kubectl port-forward or ingress
  service:
    type: ClusterIP

# ArgoCD Server - UI and API
server:
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 25m
      memory: 128Mi

  # Reduce replicas for small cluster
  replicas: 1

# Application Controller - reconciles apps
controller:
  resources:
    limits:
      cpu: 500m
      memory: 1Gi
    requests:
      cpu: 50m
      memory: 512Mi

  # Single replica for small cluster
  replicas: 1

# Repo Server - handles git operations (handles Helm templating, needs more memory)
repoServer:
  resources:
    limits:
      cpu: 500m
      memory: 1024Mi
    requests:
      cpu: 50m
      memory: 512Mi

  replicas: 1
  # Reduce the parallelism limit to avoid high memory usage during heavy concurrent manifests
  extraEnv:
    - name: ARGOCD_REPO_SERVER_PARALLELISM_LIMIT
      value: "4"

# Redis - caching layer
redis:
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 25m
      memory: 64Mi

# ApplicationSet Controller - manages ApplicationSets
applicationSet:
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 25m
      memory: 64Mi

  replicas: 1

# Notifications Controller (optional, disable if not needed)
notifications:
  enabled: false

# Dex (SSO, disable if using admin user only)
dex:
  enabled: false

# Disable HA mode (not needed for small clusters)
redis-ha:
  enabled: false
# Resource totals (approximate):
# Limits:   ~1.4 CPU, ~1.54 GB RAM
# Requests: ~0.375 CPU, ~0.896 GB RAM
# Balanced for VM.Standard.E2.1 (1 OCPU, 8GB RAM) with headroom for applications

